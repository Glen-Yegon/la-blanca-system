var test=require("tape"),hasSymbols=require("has-symbols/shams")(),utilInspect=require("../util.inspect"),repeat=require("string.prototype.repeat"),inspect=require("..");test("inspect",function(t){t.plan(5);var e=[{inspect:function(){return"!XYZ¡"}},[]],n="[ !XYZ¡, [] ]",s="[ { inspect: [Function: xyzInspect] }, [] ]";t.equal(inspect(e),n),t.equal(inspect(e,{customInspect:!0}),n),t.equal(inspect(e,{customInspect:"symbol"}),s),t.equal(inspect(e,{customInspect:!1}),s),t.throws(function(){inspect(e,{customInspect:'not a boolean or "symbol"'})},TypeError,'`customInspect` must be a boolean or the string "symbol"')}),test("inspect custom symbol",{skip:!hasSymbols||!utilInspect||!utilInspect.custom},function(t){t.plan(4);var e={inspect:function(){return"string"}};e[utilInspect.custom]=function(){return"symbol"};var n="[ symbol, [] ]",s="[ { inspect: [Function: stringInspect]"+(utilInspect.custom?", ["+inspect(utilInspect.custom)+"]: [Function: custom]":"")+" }, [] ]",o=utilInspect.custom?n:"[ string, [] ]",i=utilInspect.custom?n:s;t.equal(inspect([e,[]]),o),t.equal(inspect([e,[]],{customInspect:!0}),o),t.equal(inspect([e,[]],{customInspect:"symbol"}),i),t.equal(inspect([e,[]],{customInspect:!1}),s)}),test("symbols",{skip:!hasSymbols},function(t){t.plan(2);var e={a:1};e[Symbol("test")]=2,e[Symbol.iterator]=3,Object.defineProperty(e,Symbol("non-enum"),{enumerable:!1,value:4}),"symbol"==typeof Symbol.iterator?(t.equal(inspect(e),"{ a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }","object with symbols"),t.equal(inspect([e,[]]),"[ { a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }, [] ]","object with symbols in array")):(t.match(inspect(e),/^(?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 })$/,"object with symbols (nondeterministic symbol sham key ordering)"),t.match(inspect([e,[]]),/^\[ (?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 }), \[\] \]$/,"object with symbols in array (nondeterministic symbol sham key ordering)"))}),test("maxStringLength",function(t){t.throws(function(){inspect("",{maxStringLength:-1})},TypeError,"maxStringLength must be >= 0, or Infinity, not negative");var e=repeat("a",1e8);t.equal(inspect([e],{maxStringLength:10}),"[ 'aaaaaaaaaa'... 99999990 more characters ]","maxStringLength option limits output"),t.equal(inspect(["f"],{maxStringLength:null}),"[ ''... 1 more character ]","maxStringLength option accepts `null`"),t.equal(inspect([e],{maxStringLength:1/0}),"[ '"+e+"' ]","maxStringLength option accepts ∞"),t.end()}),test("inspect options",{skip:!utilInspect.custom},function(t){var e={};e[utilInspect.custom]=function(){return JSON.stringify(arguments)},t.equal(inspect(e),utilInspect(e,{depth:5}),"custom symbols will use node's inspect"),t.equal(inspect(e,{depth:2}),utilInspect(e,{depth:2}),"a reduced depth will be passed to node's inspect"),t.equal(inspect({d1:e},{depth:3}),"{ d1: "+utilInspect(e,{depth:2})+" }","deep objects will receive a reduced depth"),t.equal(inspect({d1:e},{depth:1}),"{ d1: [Object] }","unlike nodejs inspect, customInspect will not be used once the depth is exceeded."),t.end()}),test("inspect URL",{skip:"undefined"==typeof URL},function(t){t.match(inspect(new URL("https://nodejs.org")),/nodejs\.org/,"url can be inspected"),t.end()});