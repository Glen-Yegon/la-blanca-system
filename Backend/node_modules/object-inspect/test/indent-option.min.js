var test=require("tape"),forEach=require("for-each"),inspect=require("../");test("bad indent options",function(t){forEach([void 0,!0,!1,-1,1.2,1/0,-1/0,NaN],function(n){t.throws(function(){inspect("",{indent:n})},TypeError,inspect(n)+" is invalid")}),t.end()}),test("simple object with indent",function(t){t.plan(2);var n={a:1,b:2},e=["{","  a: 1,","  b: 2","}"].join("\n"),a=["{","\ta: 1,","\tb: 2","}"].join("\n");t.equal(inspect(n,{indent:2}),e,"two"),t.equal(inspect(n,{indent:"\t"}),a,"tabs")}),test("two deep object with indent",function(t){t.plan(2);var n={a:1,b:{c:3,d:4}},e=["{","  a: 1,","  b: {","    c: 3,","    d: 4","  }","}"].join("\n"),a=["{","\ta: 1,","\tb: {","\t\tc: 3,","\t\td: 4","\t}","}"].join("\n");t.equal(inspect(n,{indent:2}),e,"two"),t.equal(inspect(n,{indent:"\t"}),a,"tabs")}),test("simple array with all single line elements",function(t){t.plan(2);var n=[1,2,3,"asdf\nsdf"],e="[ 1, 2, 3, 'asdf\\nsdf' ]";t.equal(inspect(n,{indent:2}),e,"two"),t.equal(inspect(n,{indent:"\t"}),e,"tabs")}),test("array with complex elements",function(t){t.plan(2);var n=[1,{a:1,b:{c:1}},"asdf\nsdf"],e=["[","  1,","  {","    a: 1,","    b: {","      c: 1","    }","  },","  'asdf\\nsdf'","]"].join("\n"),a=["[","\t1,","\t{","\t\ta: 1,","\t\tb: {","\t\t\tc: 1","\t\t}","\t},","\t'asdf\\nsdf'","]"].join("\n");t.equal(inspect(n,{indent:2}),e,"two"),t.equal(inspect(n,{indent:"\t"}),a,"tabs")}),test("values",function(t){t.plan(2);var n=[{},[],{"a-b":5}],e=["[","  {},","  [],","  {","    'a-b': 5","  }","]"].join("\n"),a=["[","\t{},","\t[],","\t{","\t\t'a-b': 5","\t}","]"].join("\n");t.equal(inspect(n,{indent:2}),e,"two"),t.equal(inspect(n,{indent:"\t"}),a,"tabs")}),test("Map",{skip:"function"!=typeof Map},function(t){var n=new Map;n.set({a:1},["b"]),n.set(3,NaN);var e=["Map (2) {","  { a: 1 } => [ 'b' ],","  3 => NaN","}"].join("\n"),a=["Map (2) {","\t{ a: 1 } => [ 'b' ],","\t3 => NaN","}"].join("\n"),i=["Map (2) {",'\t{ a: 1 } => [ "b" ],',"\t3 => NaN","}"].join("\n");t.equal(inspect(n,{indent:2}),e,"Map keys are not indented (two)"),t.equal(inspect(n,{indent:"\t"}),a,"Map keys are not indented (tabs)"),t.equal(inspect(n,{indent:"\t",quoteStyle:"double"}),i,"Map keys are not indented (tabs + double quotes)"),t.equal(inspect(new Map,{indent:2}),"Map (0) {}","empty Map should show as empty (two)"),t.equal(inspect(new Map,{indent:"\t"}),"Map (0) {}","empty Map should show as empty (tabs)");var s=new Map;s.set(s,n);var o=["Map (1) {","  [Circular] => Map (2) {","    { a: 1 } => [ 'b' ],","    3 => NaN","  }","}"].join("\n"),d=["Map (1) {","\t[Circular] => Map (2) {","\t\t{ a: 1 } => [ 'b' ],","\t\t3 => NaN","\t}","}"].join("\n");t.equal(inspect(s,{indent:2}),o,"Map containing a Map should work (two)"),t.equal(inspect(s,{indent:"\t"}),d,"Map containing a Map should work (tabs)"),t.end()}),test("Set",{skip:"function"!=typeof Set},function(t){var n=new Set;n.add({a:1}),n.add(["b"]);var e=["Set (2) {","  {","    a: 1","  },","  [ 'b' ]","}"].join("\n"),a=["Set (2) {","\t{","\t\ta: 1","\t},","\t[ 'b' ]","}"].join("\n");t.equal(inspect(n,{indent:2}),e,'new Set([{ a: 1 }, ["b"]]) should show size and contents (two)'),t.equal(inspect(n,{indent:"\t"}),a,'new Set([{ a: 1 }, ["b"]]) should show size and contents (tabs)'),t.equal(inspect(new Set,{indent:2}),"Set (0) {}","empty Set should show as empty (two)"),t.equal(inspect(new Set,{indent:"\t"}),"Set (0) {}","empty Set should show as empty (tabs)");var i=new Set;i.add(n),i.add(i);var s=["Set (2) {","  Set (2) {","    {","      a: 1","    },","    [ 'b' ]","  },","  [Circular]","}"].join("\n"),o=["Set (2) {","\tSet (2) {","\t\t{","\t\t\ta: 1","\t\t},","\t\t[ 'b' ]","\t},","\t[Circular]","}"].join("\n");t.equal(inspect(i,{indent:2}),s,"Set containing a Set should work (two)"),t.equal(inspect(i,{indent:"\t"}),o,"Set containing a Set should work (tabs)"),t.end()});