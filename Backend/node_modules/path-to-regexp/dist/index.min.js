"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PathError=exports.TokenData=void 0,exports.parse=parse,exports.compile=compile,exports.match=match,exports.pathToRegexp=pathToRegexp,exports.stringify=stringify;const DEFAULT_DELIMITER="/",NOOP_VALUE=e=>e,ID_START=/^[$_\p{ID_Start}]$/u,ID_CONTINUE=/^[$\u200c\u200d\p{ID_Continue}]$/u,SIMPLE_TOKENS={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function escapeText(e){return e.replace(/[{}()\[\]+?!:*\\]/g,"\\$&")}function escape(e){return e.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}class TokenData{constructor(e,t){this.tokens=e,this.originalPath=t}}exports.TokenData=TokenData;class PathError extends TypeError{constructor(e,t){let n=e;t&&(n+=`: ${t}`),n+="; visit https://git.new/pathToRegexpError for info",super(n),this.originalPath=t}}function parse(e,t={}){const{encodePath:n=NOOP_VALUE}=t,r=[...e],o=[];let a=0,s=0;function p(){let t="";if(ID_START.test(r[a]))do{t+=r[a++]}while(ID_CONTINUE.test(r[a]));else if('"'===r[a]){let n=a;for(;a++<r.length;){if('"'===r[a]){a++,n=0;break}"\\"===r[a]&&a++,t+=r[a]}if(n)throw new PathError(`Unterminated quote at index ${n}`,e)}if(!t)throw new PathError(`Missing parameter name at index ${a}`,e);return t}for(;a<r.length;){const e=r[a],t=SIMPLE_TOKENS[e];t?o.push({type:t,index:a++,value:e}):"\\"===e?o.push({type:"escape",index:a++,value:r[a++]}):":"===e?o.push({type:"param",index:a++,value:p()}):"*"===e?o.push({type:"wildcard",index:a++,value:p()}):o.push({type:"char",index:a++,value:e})}return o.push({type:"end",index:a,value:""}),new TokenData(function t(r){const a=[];for(;;){const p=o[s++];if(p.type===r)break;if("char"===p.type||"escape"===p.type){let e=p.value,t=o[s];for(;"char"===t.type||"escape"===t.type;)e+=t.value,t=o[++s];a.push({type:"text",value:n(e)});continue}if("param"!==p.type&&"wildcard"!==p.type){if("{"!==p.type)throw new PathError(`Unexpected ${p.type} at index ${p.index}, expected ${r}`,e);a.push({type:"group",tokens:t("}")})}else a.push({type:p.type,name:p.value})}return a}("end"),e)}function compile(e,t={}){const{encode:n=encodeURIComponent,delimiter:r=DEFAULT_DELIMITER}=t,o=tokensToFunction(("object"==typeof e?e:parse(e,t)).tokens,r,n);return function(e={}){const[t,...n]=o(e);if(n.length)throw new TypeError(`Missing parameters: ${n.join(", ")}`);return t}}function tokensToFunction(e,t,n){const r=e.map(e=>tokenToFunction(e,t,n));return e=>{const t=[""];for(const n of r){const[r,...o]=n(e);t[0]+=r,t.push(...o)}return t}}function tokenToFunction(e,t,n){if("text"===e.type)return()=>[e.value];if("group"===e.type){const r=tokensToFunction(e.tokens,t,n);return e=>{const[t,...n]=r(e);return n.length?[""]:[t]}}const r=n||NOOP_VALUE;return"wildcard"===e.type&&!1!==n?n=>{const o=n[e.name];if(null==o)return["",e.name];if(!Array.isArray(o)||0===o.length)throw new TypeError(`Expected "${e.name}" to be a non-empty array`);return[o.map((t,n)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${n}" to be a string`);return r(t)}).join(t)]}:t=>{const n=t[e.name];if(null==n)return["",e.name];if("string"!=typeof n)throw new TypeError(`Expected "${e.name}" to be a string`);return[r(n)]}}function match(e,t={}){const{decode:n=decodeURIComponent,delimiter:r=DEFAULT_DELIMITER}=t,{regexp:o,keys:a}=pathToRegexp(e,t),s=a.map(e=>!1===n?NOOP_VALUE:"param"===e.type?n:e=>e.split(r).map(n));return function(e){const t=o.exec(e);if(!t)return!1;const n=t[0],r=Object.create(null);for(let e=1;e<t.length;e++){if(void 0===t[e])continue;const n=a[e-1],o=s[e-1];r[n.name]=o(t[e])}return{path:n,params:r}}}function pathToRegexp(e,t={}){const{delimiter:n=DEFAULT_DELIMITER,end:r=!0,sensitive:o=!1,trailing:a=!0}=t,s=[],p=o?"":"i",i=[];for(const r of pathsToArray(e,[])){const e="object"==typeof r?r:parse(r,t);for(const t of flatten(e.tokens,0,[]))i.push(toRegExpSource(t,n,s,e.originalPath))}let c=`^(?:${i.join("|")})`;a&&(c+=`(?:${escape(n)}$)?`),c+=r?"$":`(?=${escape(n)}|$)`;return{regexp:new RegExp(c,p),keys:s}}function pathsToArray(e,t){if(Array.isArray(e))for(const n of e)pathsToArray(n,t);else t.push(e);return t}function*flatten(e,t,n){if(t===e.length)return yield n;const r=e[t];if("group"===r.type)for(const o of flatten(r.tokens,0,n.slice()))yield*flatten(e,t+1,o);else n.push(r);yield*flatten(e,t+1,n)}function toRegExpSource(e,t,n,r){let o="",a="",s=!0;for(const p of e)if("text"!==p.type)if("param"!==p.type&&"wildcard"!==p.type);else{if(!s&&!a)throw new PathError(`Missing text before "${p.name}" ${p.type}`,r);"param"===p.type?o+=`(${negate(t,s?"":a)}+)`:o+="([\\s\\S]+)",n.push(p),a="",s=!1}else o+=escape(p.value),a+=p.value,s||(s=p.value.includes(t));return o}function negate(e,t){return t.length<2?e.length<2?`[^${escape(e+t)}]`:`(?:(?!${escape(e)})[^${escape(t)}])`:e.length<2?`(?:(?!${escape(t)})[^${escape(e)}])`:`(?:(?!${escape(t)}|${escape(e)})[\\s\\S])`}function stringifyTokens(e){let t="",n=0;function r(t){return isNameSafe(t)&&isNextNameSafe(e[n])?t:JSON.stringify(t)}for(;n<e.length;){const o=e[n++];if("text"!==o.type)if("group"!==o.type)if("param"!==o.type){if("wildcard"!==o.type)throw new TypeError(`Unknown token type: ${o.type}`);t+=`*${r(o.name)}`}else t+=`:${r(o.name)}`;else t+=`{${stringifyTokens(o.tokens)}}`;else t+=escapeText(o.value)}return t}function stringify(e){return stringifyTokens(e.tokens)}function isNameSafe(e){const[t,...n]=e;return ID_START.test(t)&&n.every(e=>ID_CONTINUE.test(e))}function isNextNameSafe(e){return!e||"text"!==e.type||!ID_CONTINUE.test(e.value[0])}exports.PathError=PathError;